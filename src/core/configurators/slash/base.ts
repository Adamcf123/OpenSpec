import { FileSystemUtils } from '../../../utils/file-system.js';
import { TemplateManager, SlashCommandId } from '../../templates/index.js';

export interface SlashCommandTarget {
  id: SlashCommandId;
  path: string;
  kind: 'slash';
}

const ALL_COMMANDS: SlashCommandId[] = ['proposal', 'apply', 'archive'];

export abstract class SlashCommandConfigurator {
  abstract readonly toolId: string;
  abstract readonly isAvailable: boolean;

  getTargets(): SlashCommandTarget[] {
    return ALL_COMMANDS.map((id) => ({
      id,
      path: this.getRelativePath(id),
      kind: 'slash'
    }));
  }

  async generateAll(projectPath: string, _openspecDir: string): Promise<string[]> {
    const createdOrUpdated: string[] = [];

    for (const target of this.getTargets()) {
      const body = this.normalizeBody(this.getBody(target.id));
      const filePath = FileSystemUtils.joinPath(projectPath, target.path);

      if (await FileSystemUtils.fileExists(filePath)) {
        await this.updateBody(filePath, body);
      } else {
        const frontmatter = this.getFrontmatter(target.id);
        const sections: string[] = [];
        if (frontmatter) {
          sections.push(frontmatter.trim());
        }
        sections.push(body.trim());
        const content = sections.join('\n\n') + '\n';
        await FileSystemUtils.writeFile(filePath, content);
      }

      createdOrUpdated.push(target.path);
    }

    return createdOrUpdated;
  }

  async updateExisting(projectPath: string, _openspecDir: string): Promise<string[]> {
    const updated: string[] = [];

    for (const target of this.getTargets()) {
      const filePath = FileSystemUtils.joinPath(projectPath, target.path);
      if (await FileSystemUtils.fileExists(filePath)) {
        const body = this.normalizeBody(this.getBody(target.id));
        await this.updateBody(filePath, body);
        updated.push(target.path);
      }
    }

    return updated;
  }

  protected abstract getRelativePath(id: SlashCommandId): string;
  protected abstract getFrontmatter(id: SlashCommandId): string | undefined;

  protected getBody(id: SlashCommandId): string {
    return TemplateManager.getSlashCommandBody(id).trim();
  }

  private normalizeBody(body: string): string {
    const trimmed = body.trimStart();
    if (trimmed.startsWith('---')) {
      const end = trimmed.indexOf('\n---', 3);
      if (end !== -1) {
        const after = trimmed.slice(end + '\n---'.length);
        // Drop one optional blank line after closing fence
        const withoutLeadingBlank = after.replace(/^\s*\n/, '');
        return withoutLeadingBlank.trim();
      }
    }
    return body.trim();
  }

  // Resolve absolute path for a given slash command target. Subclasses may override
  // to redirect to tool-specific locations (e.g., global directories).
  resolveAbsolutePath(projectPath: string, id: SlashCommandId): string {
    const rel = this.getRelativePath(id);
    return FileSystemUtils.joinPath(projectPath, rel);
  }

  protected async updateBody(filePath: string, body: string): Promise<void> {
    const content = await FileSystemUtils.readFile(filePath);

    // If file contains frontmatter (starts with ---), preserve it and replace body after the first blank line following frontmatter.
    if (content.startsWith('---')) {
      const endOfFrontmatter = content.indexOf('\n---', 3);
      if (endOfFrontmatter !== -1) {
        const fmEnd = endOfFrontmatter + '\n---'.length;
        // Find first blank line after frontmatter to separate sections
        const rest = content.slice(fmEnd);
        const bodyStart = rest.match(/^\s*\n/) ? fmEnd + rest.match(/^\s*\n/)![0].length : fmEnd;
        const updated = content.slice(0, bodyStart) + '\n' + body.trim() + '\n';
        await FileSystemUtils.writeFile(filePath, updated);
        return;
      }
    }

    // Fallback: replace entire file with body (no OPENSPEC markers anymore)
    await FileSystemUtils.writeFile(filePath, body.trim() + '\n');
  }
}
