---
description: 起草新的 OpenSpec 提案；生成变更骨架并完成最小可验证规格
argument-hint: [title|description|prelude-id] [primary-capability]
allowed-tools: *
---

## Guardrails
- 最小可行但完整：一次成型产出 proposal/design/tasks 与至少一个 specs（各文件达到可审阅粒度，避免占位符与空段落）。
- 采用动词开头、短横线的 `change-id`，避免与现有条目冲突。
- 写新需求前先复用或对齐既有 Requirement/Scenario。

## 上下文
- 规范：@openspec/AGENTS.md
- 项目现状：@openspec/project.md
- 参考清单：!`openspec list`，!`openspec list --specs`

## 参数与 change-id 生成
- 若 `$1` 是合法、未占用的 `change-id`（形如 `verb-noun[-qualifier]`），直接使用。
- 否则从 `$ARGUMENTS`（标题/描述）生成 `change-id`：
  - 规则：小写、动词开头、短横线分隔、去停用词、最长 6 词。
  - 确保唯一：若冲突追加日期/序号（如 `-20251106` 或 `-v2`）。
- 可选 `$2` 作为首个 `capability` 名称（小写短横线）。

## 先决条件
- 不与现有变更 ID 冲突：!`openspec list` 检查。
- 具备在 `openspec/changes/<id>/` 下创建与写入文件的权限。

## 执行步骤（脚手架 → 细化 → 严格校验）
- [ ] 目录与文件骨架：创建 `openspec/changes/<id>/{proposal.md, design.md, tasks.md}`（必要时预建 `specs/<capability>/` 目录）
- [ ] 若提供 `capability`：创建 `openspec/changes/<id>/specs/<capability>/spec.md`
- [ ] 填充内容（最小完整度）：
  - proposal.md：问题（含用户/系统信号）、证据（日志/指标/用户反馈）、目标/非目标（明确范围边界）、里程碑（MVP→验证→收敛）、风险与缓解、回滚方案、测评计划（验收信号/成功标准）
  - design.md：背景（现状/痛点/约束）、架构方案（数据流/接口契约/依赖）、决策记录（ADR）、失败模式与降级、Rollout/Rollback、E2E 测试计划
  - tasks.md：按发现/实现/验证/发布分组的小而可验任务（每项包含输入、操作、产出与证据钩子）；并细化到步骤/函数级：
    - 任务要素：目标一句话｜涉及文件路径｜受影响模块/函数名与签名｜实现步骤（1–3 步）｜边界条件与失败模式｜验证方式（单测/集成/手测）｜产出与验收证据链接
    - 函数级要求：给出函数签名、返回类型与错误处理策略（如抛错/返回结果类型），必要时附简短伪代码或实现要点
    - 路径与提交：标注需修改/新增的相对路径与导出项，避免笼统“更新某模块”
    - 测试先行：列出需新增/更新的测试文件与用例名称，标明覆盖的分支与边界
    - 证据钩子：提供可复现实验命令、关键日志/截图或 diff 片段存放路径，用于在 apply 阶段引用
  - specs/<capability>/spec.md：
    - 使用 `## ADDED|MODIFIED|REMOVED Requirements`
    - 每条 Requirement 至少 1 个 `#### Scenario:`
    - 与相关能力交叉引用
- [ ] 对齐与复用：!`rg -n "Requirement:|Scenario:" openspec/specs`（不可用则跳过）
- [ ] 获取变更 ID：设置 `ID=<change-id>` 或从创建输出中捕获
- [ ] 严格校验：`openspec validate "$ID" --strict`；失败则读取问题、修复并重试

## 日志打点与 LLM 查看流程（强制）
- 日志键与结构：`ts` 时间戳、`level`、`component`、`func`、`event`、`status`、`change_id`、`request_id`、`duration_ms`、`error_code`（异常时必填）、`sample_rate`
- 输出格式：JSON Lines（.jsonl），每条一行；禁止多行堆栈（改写为单行摘要+stack_id）
- 覆盖面：每个入口函数“开始/结束/耗时”，每个核心函数“成功/失败/边界”；错误必含 `error_code`
- 存储与切分：`logs/app-YYYYMMDD.jsonl` 按天切分；超阈值滚动；生成 `logs/index.json`（计数/窗口摘要）
- 查看工具与流程（项目应提供脚本或等价命令；详见 @openspec/logs/logs-tooling.md 模板）：
  1) `logs:summary` → 统计按 component/func/error_code 分布
  2) `logs:errors` → 最近 N 分钟错误 Top-K
  3) `logs:view --component <c> --since <t>` → 聚焦窗口
  4) 将摘要/片段归档到 `artifacts/<id>/logs/*.txt`
- LLM 检查时序（固定）：Summary → Top errors → Focused window → Correlate with change_id → Evidence

## tasks.md 模板示例（自动生成于 openspec/changes/_template/tasks.md，可复制为 openspec/changes/<id>/tasks.md 并按需细化）
```markdown
## 0. Discovery & Alignment
- [ ] 0.1 研读上下文 → 打开 `openspec/changes/<id>/proposal.md` 与相关 `specs/*/spec.md`
- [ ] 0.2 代码定位 → 列出受影响文件与模块（相对路径）
- [ ] 0.3 风险记录 → 在 proposal.md 的风险章节补充发现

## 1. Implementation
- [ ] 1.1 函数实现：<模块/函数> → `src/<path>/<file>.ts`
      - 签名：`function <name>(a: TypeA, b: TypeB): Result<Type>`
      - 要点：<核心逻辑 2–3 点>
      - 错误处理：<抛错类型/返回错误值/Result>
- [ ] 1.2 辅助函数：<函数> → `src/<path>/<file>.ts`
      - 签名：`async function <helper>(input: X): Promise<Y>`
      - 要点：<边界/重试/缓存等>
- [ ] 1.3 接线改动：<调用点> → `src/<path>/<component>.tsx`
      - 步骤：1) 注入依赖 2) 调用新函数 3) 处理错误态

## 2. Validation
- [ ] 2.1 单测：`test/<path>/<file>.test.ts`
      - 用例：<case-1> 覆盖成功分支；<case-2> 覆盖异常/边界
- [ ] 2.2 集成/E2E：脚本/场景名 → 断言关键输出或 UI
- [ ] 2.3 证据：保留命令输出/日志/截图路径 → `artifacts/<id>/`
```


## 验收标准
- proposal/design/tasks 三文件均存在且内容完整清晰。
- 至少 1 个 capability 具备可验证的 `spec.md`。
- `openspec validate "$ID" --strict` 通过。

## 返回内容
- `change-id` 与创建文件清单。
- 关键片段摘要（proposal/design 要点与首个 Requirement/Scenario）。
- 严格校验结果概要。
